#!/usr/bin/env bb

(require '[clojure.string :as str]
         '[clojure.pprint :refer [cl-format]]
         '[clojure.tools.cli :refer [parse-opts]]
         '[babashka.process :refer [process $ check]])

(def rsync-copy
  '[rsync --verbose --progress --human-readable --compress --archive
    --hard-links --one-file-system])

(defn get-challenge-from-latest-tag
  "Get the most recently created tag"
  []
  (let [fulltag (-> (process '[git for-each-ref refs/tags --sort=-committerdate
                               "--format=%(refname)"  --count=1])
                    :out slurp
                    (str/replace #"^refs/tags/(.+)\n$" "$1"))]
    (->> fulltag
         (re-matches #"^[^\d]+(\d+$)")
         second
         (#(Integer/parseInt %)))))

(defn get-tw-dirs
  "Get the old and new directories."
  [prev-challenge challenge]
  (->> [prev-challenge challenge]
       (map #(format "challenge-%03d/tyler-wardhaugh/" %))))

(defn rename-clojure-resources
  [new prev-challenge challenge]
  (let [gen-classdir (fn [tail]
                       (io/file (format "%s/clojure/src/tw/weekly/c%d" new tail)))
        gen-testfile (fn [part]
                       (io/file (format "%s/clojure/test/tw/weekly/c%d_test.clj" new part)))]
    (.renameTo (gen-classdir prev-challenge) (gen-classdir challenge))
    (.renameTo (gen-testfile prev-challenge) (gen-testfile challenge))))

(defn rsync-prev-files
  [old new]
  (let [cmd (concat rsync-copy
                    '[-f ".,- .rsync-filter-excludes"]
                    [old new])]
    (cl-format true "Running: [[~{~s~^ ~}]]~%" cmd)
    @(process cmd {:out :inherit})))

(def cli-options
  [["-s" "--copy-source CHALLENGE" "a challenge to source files from"
    ; Negative numbers are treated as negative offsets, -1 (meaning the previous challenge) is the default.
    :default -1
    :parse-fn #(Integer/parseInt %)
    :validate [#(not (zero? %)) "Must refer to an existing challenge directory."]]
   ["-h" "--help"]])

(defn error-msg [errors]
  (str "The following errors occurred while parsing your command:\n\n"
       (str/join \newline errors)))

(defn exit [status msg]
  (println msg)
  (System/exit status))

(defn usage [options-summary]
  (cl-format nil "usage: ~a [options]~2%options:~%~a~%"
             (-> *file* io/file .getName)
             options-summary))

(defn validate-args
  "Validate command line arguments. Either return a map indicating the program
  should exit (with a error message, and optional ok status), or a map
  indicating the action the program should take and the options provided."
  [args]
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)]
    (cond
      (:help options) {:exit-message (usage summary) :ok? true}
      errors {:exit-message (error-msg errors)}
      :else {:options options})))

(defn -main
  "Prepare for the next Challenge"
  [& args]
  (let [{:keys [action options exit-message ok?]} (validate-args args)]
    (if exit-message
      (exit (if ok? 0 1) exit-message)
      (let [copy-source (:copy-source options)
            challenge (get-challenge-from-latest-tag)
            prev-challenge (if (neg? copy-source)
                             (+ challenge copy-source)
                             copy-source)
            [old new] (get-tw-dirs prev-challenge challenge)]
        (do (rsync-prev-files old new)
            (rename-clojure-resources new prev-challenge challenge)
            nil)))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
